package day2; /**
 * @author : zhousy
 * @date : 2022/10/14 11:46
 * @version : 1.0
 */

/**
 *  垃圾回收：
 *
 *  1.如何判断对象可以回收
 *  2.垃圾回收算法
 *  3.分代垃圾回收
 *  4.垃圾回收器(4种)：
 *
 *  5.垃圾回收调优
 *    -1需要掌握的东西
 *     掌握GC相关的虚拟机参数(CMS回收的并发线程数....)：
 *       "C:\Program Files\Java\jdk1.8.0_162\bin\java" -XX:+PrintFlagsFinal -version | findstr "GC"
 *     掌握相关工具：jmap jps jstack jvisvual......
 *     明白调优和应用、环境相关，要凭借经验
 *
 *    -2调优领域
 *      内存、锁竞争、cpu占用、io
 *
 *    -3确定目标
 *      低延迟(互联网项目追求的是响应时间) 还是高吞吐量(科学运算)，选择合适的回收期
 *      CMS，G1，ZGC                     ParallelGC
 *
 *    -4最快的GC是不发生GC
 *      查看fullgc前后的内存占用，考虑下面几个问题
 *         是否加载了无用数据： 例如：resultSet = statement.executeQuery("select * from 大表")
 *         数据表是否太臃肿：查询出关联的无用数据 使用的类型大小(new Object就占用16字节  能用4个字节的基本类型就不要用24个字节的包装类型)
 *         是否存在内存泄露：例如：static Map map= 一直put就会导致内存泄露；
 *                       可以考虑第三方缓存比如redis 会考虑对象的过期，自己做内存管理不会使用到堆；
 *                       可以考虑第三方缓存比如ehcache 缓存中的对象可以使用堆外内存；
 *                       或者使用软弱引用。
 *
 *    -5新生代调优
 *      新生代的特点：
 *          -new一个对象就会在伊甸园中分配，速度非常快 (因为每个线程都会在伊甸园中分配自己的私有区域TLAB new一个对象会优先检查该线程的伊甸园私有区域是否
 *                                         有内存，如果有则分配，这样多个线程同时分配对象空间不会造成内存混乱问题，这是jvm对线程并发安全进行保护。)
 *          -MinorGC的时间远远低于FullGC
 *          -死亡对象的回收代价都是0 所有新生代的GC算法都是复制算法
 *          -大部分对象用过即死
 *      如何调优：
 *         1. 调大(-Xmn)新生代是最有效的方式，但是不是越大越好(如果新生代空间大了，老年代就小了，因为新生代空间大不会触发垃圾回收，但是老年代空间不足就会引发fullgc
 *         ->fullgc相比minorgc的stw时间长一倍) 建议新生代大小大于堆的25%小于堆的50%。
 *         2. 开发中发现 新生代空间大小越大吞吐量越大，但是新生代空间大小到达一个临界值后吞吐量开始减少，所以我们要找到那个临界值
 *         3. 新生代GC采用的是复制算法，复制算法主要是标记+复制，标记的时间很短，复制比较长，
 *            但是由于是新生代，大部分对象用过即死，所以即使新生代内存很大也对复制的时间影响不大。
 *         4. 可以估算出新生代内存划分为多少合适  例如：【并发量*（请求对象+响应对象）】 1000*（512KB）=512M
 *            只要新生代内存大于512M这一次请求就不会或者较少的触发新生代GC
 *         5. 幸存区大到能保留【当前活跃对象(当前活跃但是一定会被回收的对象)+需要晋升的对象(要晋升老年代的对象)】
 *            当幸存区内存不足的时候，jvm就会动态调整晋升阈值，导致当前活跃对象晋升老年代，由于老年代内存不足才会回收，
 *            就变相的延长了一个马上需要回收对象的寿命，所以要保证幸存区的内存大小为【当前活跃对象+需要晋升的对象】
 *         6. 晋升阀值配置得当，让长时间存活对象尽快晋升 （由于新生代内存不足都是复制算法实现，会将幸存区的存活对象从from复制到to，
 *                                                这样复制来复制去对性能反而是一种负担，所以要尽快晋升）
 *            -使用-XX:MaxTenuringThreshold=threshold 设置晋升阈值
 *            -使用-XX:+PrintTenuringDistribution 查看幸存区对象寿命情况和占用内存空间
 *
 *    -6老年代调优
 *      以CMS为例： CMS老年代内存越大越好，先尝试不做调优，如果没有fullgc那已经很好了，否则先尝试调整新生代；
 *      如果调整了还发生fullgc 再观察发生fullgc时老年代的内存占用，将老年代内存预设调大1/4 ~1/3
 *      ->使用-XX:CMSInitiatingOccupancyFraction=percent 设置多大才进行GC 一般设置为75% 预留25%给浮动垃圾
 *
 *    -7案例
 *      1.FullGC和MinorGC频繁
 *        分析：GC频繁说明内存空间紧张。业务高峰期新生代大量创建对象导致内存不足，触发MinorGC，幸存区内存不足导致晋升阈值降低寿命短的都晋升到老年代，
 *             老年代存了大量寿命短的对象，导致内存不足触发FullGC。可以试着先增大新生代（内存充裕就MinorGC不那么频繁了），
 *             再增大幸存区空间和晋升阈值（生命周期较短的对象就会留着新生代不会进去老年代）。
 *        *内存优化应该先从新生代开始。
 *
 *      2.请求高峰期发生Full GC，单词暂停时间特别长(CMS)
 *         分析：CMS分为初始化标记、并发标记、重新标记、并发清理，其中初始化标记和并发标记都是比较快的，通过查看GC日志可以看到每阶段耗费的时间，
 *              发现重新标记阶段耗时2秒比较多，cms做重新标记的时候会扫描整个堆内存，扫描老年代也会扫描新生代，业务高峰期新生代对象比较多，
 *              扫描的时间就会很长。
 *         *可以在重新标记之前先做一个MinorGC减少新生代对象 可以通过-XX:+CMSScavengeBeforeRemark参数
 *
 *      3.老年代充裕情况下，发生Full GC(CMS jdk1.7)
 *          分析：GC日志里面没有发现由于空间不足导致并发失败或者是空间碎片的字样，不是由于老年代空间不足引发的Full GC，1.8是用元空间做方法区的实现
 *               1.7是永久代来做方法区的实现，永久代的空间不足也会导致Full GC，增大永久代的初始和最大值就不会再导致Full GC
 */
public class GC_5 {
}
