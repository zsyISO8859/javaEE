package day2; /**
 * @author : zhousy
 * @date : 2022/10/13 11:07
 * @version : 1.0
 */

/**
 *  垃圾回收：
 *
 *  1.如何判断对象可以回收
 *  2.垃圾回收算法
 *  3.分代垃圾回收
 *  4.垃圾回收器(4种)：
 *      -串行SerialGC （单线程，适合堆内存较小的个人电脑（cpu个数少））
 *          -XX:+UseSerialGC = Serial + SerialOld 即新生代采用复制算法 老年代使用标记整理算法
 *          执行模式：多个线程在运行，此时需要垃圾回收，先让所有线程运行到安全点，再阻塞用户线程并开启垃圾回收线程，回收完所有线程恢复运行
 *
 *      -吞吐量优先(ParallelGC) （多线程，适合堆内存较大的多核cpu 让单位时间内的STW的时间最短：0.2 0.2 = 0.4[单位时间发生2次GM耗时0.4]）
 *          -XX:+UseParallelGC~-XX:+UseParallelOldGC jdk1.8默认就是开启的  几核就开启几个线程做GC
 *          -XX:ParallelGCThreads=n  手动调整几个线程做GC
 *          -XX:UseAdaptiveSizePolicy : 会动态调整伊甸园和幸存区和堆的大小还要晋升阈值大小
 *          -XX:GCTimeRatio=ratio : 通过调整堆大小达到设置吞吐量的目标，
 *              ->调整垃圾回收的时间和总时间的占比 1/(1+ratio) = 1/100 = 0.01 即垃圾回收时间不能超过总时间的1%，不然会以堆扩容来达到这个目标。
 *          -XX:MaxGCPauseMillis=ms : 堆的垃圾回收时间，
 *              ->一般和上面的ratio参数是冲突的，因为要想GC的暂停时间少，堆就要小，要达到ratio的目标堆就需要大。
 *
 *      -响应时间优先(ConcMarkSweepGC)（多线程，适合堆内存较大，需要多核cpu GC的时候让单次STW的时间最短：0.1 0.1 0.1 0.1 0.1 = 0.5[单位时间发生5次GC耗时0.5]）
 *          -工作流程：多个cpu并行执行，老年代发生内存不足，进程到达安全点并进行阻塞(STW)，cms执行初始标记动作(非常快)，用户线程恢复运行，
 *              ->与此同时GC线程并发标记找出垃圾(无需STW)，线程全部到达安全点，此时需要STW执行重新标记，
 *                用户线程继续执行且同步进行并发垃圾清理。(只有初始标记和重新标记才需要STW)
 *          -XX:+UseConcMarkSweepGC(基于标记清除算法的GC)         ~  -XX:+UseParNewGC       ~ SerialOld
 *              ->GC和用户线程可以并发执行，STW时间短，工作于老年代       工作于新生代             第一个垃圾回收器发生问题就会切换到此垃圾回收器
 *          -XX:CMSInitiatingOccupancyFraction=percent 设置何时进行垃圾回收的内存占比
 *              ->由于CMS和用户进程并发执行所以会产生浮动垃圾(用户线程新产生的垃圾)，所以就得预留浮动垃圾的空间，此参数可以设置老年代内存占比多少就触发GC
 *          -XX:+CMSScavengeBeforeRemark 参数可以做到在重新标记前先执行一次新生代GC。
 *              ->因为老年代和新生代之间的对象存在跨代引用，因此老年代进行GC Roots扫描时也会扫描新生代，
 *                在重新标记前先执行一次新生代GC，就可以少扫描一些对象，重新标记阶段的性能也能因此提升。 (补充：+就是打开 -就是禁用)
 *              (补充CMS存在的最大问题：CMS是标记清除算法可能产生很多内存碎片，minorGC不足且老年代因为内存碎片也不足，
 *              造成并发失败，CMS垃圾回收器就会退化成SerialOld进行内存整理 所以GC时间就会飙升)
 *
 *      -G1（Garbage first） jdk9作为默认GC，废除了CMS
 *          ->同时注重吞吐量和低延迟 ； 适合超大堆内存，会将堆内存划分成多个大小相等的区域，每个区域都能作为伊甸园幸存区老年代巨型对象区
 *            ；整体采用标记整理算法，区域直接采用复制算法
 *          ->-XX:UseG1GC jdk1.8启动G1垃圾回收器参数
 *          ->G1垃圾回收阶段(3阶段) 新生代GC ~ 新生代GC+并发标记 ~ 混合GC
 *            新生代：新生代内存不足进入幸存区，再不足晋升老年代
 *            新生代GC+并发标记： 新生代进行GC root初始化标记 老年代占用空间达到阈值默认：45%，进行并发标记(根据GCRoot找到别的对象，且不会STW)
 *            混合GC： 执行最终标记，会STW且标记并发标记产生的浮动垃圾；执行拷贝存活，也会STW，会回收垃圾最多的老年代
 *          ->新生代使用卡表的方式加速垃圾回收，避免遍历整个GC Root，老年代区域被分为一个个卡表如果引用了新生代的对象就被标记为脏卡；
 *            伊甸园区的卡表记录了有哪些脏卡，有个异步的线程去完成脏卡的更新操作。
 *          ->重新标记的实现：remark会对对象的引用进一步检查，当对象的引用被改变之前jvm给它加一个写屏障拦住，只要对象引用改变，写屏障的代码就会执行，
 *            把对象并放入一个队列中，变成灰色表示没处理完，重新标记阶段会STW且从队列取出对象，如果有引用就变成黑色对象不会被GC
 *          ->jdk8u20默认开启 字符串去重复 将所有字符串放入一个队列，当新生代回收的时候G1检查是否有字符串重复，如果一样就让他们引用同一个char[].优点：节省大量内存。
 *          ->jdk8u40默认开启 并发标记类卸载：所有对象经过并发标记后就知道哪些类不被使用，当一个类加载器的所有类都不再使用，则卸载它加载的所有类。
 *          ->jdk8u60巨型对象：一个对象大于region的一半的时候就被称为巨型对象
 *                    G1不会对巨型对象进行拷贝 回收时被优先考虑
 *                    老年代的卡表会引用巨型对象，卡表就会标记为脏的，当某个巨型对象与老年代的引用为0时，巨型对象就可以在新生代的GC的时候回收掉了。
 *          ->jdk9并发标记起始时间的调整： 并发标记必须在堆空间沾满前完成，否则退化成FullGC
 *                                    jdk9之前需要使用-XX:InitiatingHeapOccupancyPercent设置内存超过45%后进行并发标记和混合GC
 *                                    jdk9可以动态调整：-XX:InitiatingHeapOccupancyPercent设置默认阈值45%
 *                                                   GC的时候进行数据采集并动态调整阈值，总会保证一个空闲空间容纳浮动垃圾
 *
 *
 *
 *      *SerialGC、ParallelGC、CMS、G1的新生代内存不足发生的垃圾收集都可以称为minor gc
 *      *SerialGC、ParallelGC的老年代内存不足发生的垃圾收集都可以称为full gc
 *      *G1的老年代内存不足发生垃圾收集分2种情况：
 *         1.老年代和堆内存占比达到45%触发并发标记阶段和混合收集阶段，回收速度>产生垃圾速度 这时候处于并发垃圾收集阶段。
 *         2.................。。。。。。。。。。。。。。。。。。。回收速度<产生垃圾速度 这时候并发收集失败，退化为串行收集就会full gc
 *      *CMS并发收集失败，退化为串行收集就会full gc
 *
 *
 *  5.垃圾回收调优
 */
public class GC_4 {
}
